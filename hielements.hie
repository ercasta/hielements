## Hielements Self-Description
## This file describes the structure of the Hielements project itself,
## demonstrating the language's ability to model hierarchical software systems.

import files
import rust

## The Hielements project - a language for describing software structure
element hielements:
    scope root = files.folder_selector('.')
    
    check files.exists(root, 'Cargo.toml')
    check files.exists(root, 'README.md')
    check files.exists(root, 'LICENSE')
    
    ## Core library providing lexing, parsing, interpretation
    element core:
        scope src = files.folder_selector('crates/hielements-core/src')
        scope crate = rust.crate_selector('hielements-core')
        
        check files.exists(src, 'lib.rs')
        
        ## Lexer - tokenizes .hie source files using logos
        element lexer:
            scope module = rust.module_selector('lexer')
            
            ## Connection points: what the lexer produces
            connection_point token_output = rust.struct_selector('Token')
            connection_point token_kinds = rust.enum_selector('TokenKind')
            
            check rust.struct_exists('Lexer')
            check rust.enum_exists('TokenKind')
            check rust.has_tests(module)
            check rust.has_docs(module)
        
        ## Parser - produces AST from token stream
        element parser:
            scope module = rust.module_selector('parser')
            scope lexer_module = rust.module_selector('lexer')
            
            ## Connection points: what parser consumes and produces
            connection_point ast_output = rust.struct_selector('Program')
            
            check rust.struct_exists('Parser')
            check rust.function_exists('parse')
            check rust.has_tests(module)
            
            ## Behavioral: Parser depends on lexer for tokens
            check rust.depends_on(module, lexer_module)
        
        ## AST - typed representation of parsed programs
        element ast:
            scope module = rust.module_selector('ast')
            
            ## Connection points: AST types used by other components
            connection_point program_type = rust.struct_selector('Program')
            connection_point element_type = rust.struct_selector('Element')
            connection_point expression_type = rust.enum_selector('Expression')
            
            check rust.struct_exists('Program')
            check rust.struct_exists('Element')
            check rust.enum_exists('Expression')
            
            ## Template support structures
            check rust.struct_exists('Template')
            check rust.struct_exists('TemplateImplementation')
            check rust.struct_exists('TemplateBinding')
        
        ## Interpreter - semantic validation and check execution
        element interpreter:
            scope module = rust.module_selector('interpreter')
            scope parser_module = rust.module_selector('parser')
            scope stdlib_module = rust.module_selector('stdlib')
            scope lexer_module = rust.module_selector('lexer')
            
            ## Connection points: interpreter interfaces
            connection_point check_output = rust.enum_selector('CheckResult')
            
            check rust.struct_exists('Interpreter')
            check rust.function_exists('validate')
            check rust.function_exists('run')
            
            ## Behavioral: Interpreter depends on parser (for AST types)
            check rust.depends_on(module, parser_module)
            
            ## Behavioral: Interpreter depends on stdlib for check execution
            check rust.depends_on(module, stdlib_module)
            
            ## Behavioral: Interpreter should NOT directly depend on lexer
            ## (it goes through parser's AST abstraction)
            check rust.no_dependency(module, lexer_module)
        
        ## Diagnostics - error reporting infrastructure
        element diagnostics:
            scope module = rust.module_selector('diagnostics')
            
            ## Connection point: error types used throughout
            connection_point diagnostic_type = rust.struct_selector('Diagnostic')
            
            check rust.struct_exists('Diagnostic')
            check rust.struct_exists('Diagnostics')
            check rust.enum_exists('DiagnosticSeverity')
        
        ## Standard Library
        element stdlib:
            scope module = rust.module_selector('stdlib')
            scope stdlib_src = files.folder_selector('crates/hielements-core/src/stdlib')
            scope parser_module = rust.module_selector('parser')
            scope interpreter_module = rust.module_selector('interpreter')
            
            ## Connection point: extension interface for adding new libraries
            connection_point library_trait = rust.trait_selector('Library')
            connection_point value_type = rust.enum_selector('Value')
            
            check files.exists(stdlib_src, 'mod.rs')
            check files.exists(stdlib_src, 'files.rs')
            check files.exists(stdlib_src, 'rust.rs')
            
            check rust.trait_exists('Library')
            check rust.struct_exists('LibraryRegistry')
            check rust.enum_exists('Value')
            check rust.enum_exists('CheckResult')
            
            ## Behavioral: stdlib is a leaf dependency - should NOT depend on parser/interpreter
            check rust.no_dependency(module, parser_module)
            check rust.no_dependency(module, interpreter_module)
            
            ## Files library - file system operations
            element files_library:
                scope files_module = files.file_selector('crates/hielements-core/src/stdlib/files.rs')
                
                check rust.struct_exists('FilesLibrary')
                check rust.implements('FilesLibrary', 'Library')
                check rust.has_tests(files_module)
            
            ## Rust library - Rust code analysis
            element rust_library:
                scope rust_module = files.file_selector('crates/hielements-core/src/stdlib/rust.rs')
                
                check rust.struct_exists('RustLibrary')
                check rust.implements('RustLibrary', 'Library')
                check rust.has_tests(rust_module)
            
            ## External library support - allows user-defined plugins
            element external:
                scope external_module = files.file_selector('crates/hielements-core/src/stdlib/external.rs')
                
                check files.exists(stdlib_src, 'external.rs')
                check rust.struct_exists('ExternalLibrary')
                check rust.implements('ExternalLibrary', 'Library')
                check rust.struct_exists('ExternalLibraryConfig')
                check rust.function_exists('load_external_libraries')
        
        ## Span tracking for source locations
        element span:
            scope module = rust.module_selector('span')
            
            ## Connection point: location types used for error reporting
            connection_point span_type = rust.struct_selector('Span')
            connection_point position_type = rust.struct_selector('Position')
            
            check rust.struct_exists('Position')
            check rust.struct_exists('Span')
        
        ## ===== Core Pipeline Connections =====
        ## These checks verify the data flow through the compilation pipeline:
        ## Source -> Lexer -> Parser -> Interpreter -> Results
        ## NOTE: Cross-element connection point references (e.g., lexer.token_output)
        ## require proper scope resolution - simplified for now using direct module refs
        
        scope lexer_mod = rust.module_selector('lexer')
        scope parser_mod = rust.module_selector('parser')
        scope interpreter_mod = rust.module_selector('interpreter')
        scope ast_mod = rust.module_selector('ast')
        
        ## Verify parser uses lexer types (Token, TokenKind)
        check rust.depends_on(parser_mod, lexer_mod)
        
        ## Verify interpreter uses parser/AST types (Program, etc)
        check rust.depends_on(interpreter_mod, ast_mod)
    
    ## CLI - command-line interface
    element cli:
        scope cli_src = files.folder_selector('crates/hielements-cli/src')
        scope main_module = rust.module_selector('main')
        scope core_crate = rust.crate_selector('hielements-core')
        
        check files.exists(cli_src, 'main.rs')
        check rust.function_exists('main')
        check rust.struct_exists('Cli')
        check rust.enum_exists('Commands')
        
        ## Behavioral: CLI depends on core library
        check rust.depends_on(main_module, core_crate)
        
        ## Behavioral: Core should NOT depend on CLI (proper layering)
        check rust.no_dependency(core_crate, cli_src)
    
    ## VS Code Extension - editor integration
    element vscode_extension:
        scope ext_src = files.folder_selector('vscode-extension')
        
        check files.exists(ext_src, 'package.json')
        
        ## Language configuration
        element language_config:
            scope config = files.file_selector('vscode-extension/language-configuration.json')
            check files.exists(ext_src, 'language-configuration.json')
        
        ## Syntax highlighting
        element syntax:
            scope syntaxes = files.folder_selector('vscode-extension/syntaxes')
            check files.exists(syntaxes, 'hielements.tmLanguage.json')
        
        ## Extension code
        element extension:
            scope main = files.file_selector('vscode-extension/src/extension.ts')
            check files.exists(ext_src, 'src/extension.ts')
    
    ## Documentation
    element documentation:
        scope docs = files.folder_selector('doc')
        
        check files.exists(docs, 'language_reference.md')
        check files.exists(docs, 'technical_architecture.md')
        check files.exists(docs, 'summary.md')
        check files.exists(docs, 'external_libraries.md')
    
    ## Examples
    element examples:
        scope examples = files.folder_selector('examples')
        
        check files.exists(examples, 'minimal.hie')
        check files.exists(examples, 'simple.hie')
        check files.exists(examples, 'microservices.hie')
        check files.exists(examples, 'plugin_example.hie')
        check files.exists(examples, 'template_compiler.hie')
        check files.exists(examples, 'template_microservice.hie')
    
    ## CI/CD and automation
    element cicd:
        scope github_dir = files.folder_selector('.github')
        scope workflows = files.folder_selector('.github/workflows')
        
        ## GitHub Actions workflows
        check files.exists(workflows, 'ci.yml')
        check files.exists(workflows, 'codeql.yml')
        
        ## Dependabot configuration
        check files.exists(github_dir, 'dependabot.yml')
