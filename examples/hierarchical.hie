# Example: Hierarchical Checks
# Demonstrates hierarchical requirements and connection boundaries
# Using the unified syntax: requires/allows/forbids [descendant] ...
# Note: These keywords are only allowed in templates, not regular elements.

import files
import rust

## ============================================================================
## Templates
## ============================================================================

## Dockerized Template
## Requires that at least one descendant element has a docker configuration.
pattern dockerized:
    ## At least one descendant must have a docker scope
    requires descendant scope dockerfile = docker.file_selector('Dockerfile')
    
    ## At least one descendant must have health check configured
    requires descendant check docker.has_healthcheck(dockerfile)

## Observable Template
## Requires that at least one descendant exposes metrics for monitoring.
pattern observable:
    ## At least one descendant must have metrics endpoint (with named element and implements)
    requires descendant element metrics_service implements metrics_base

## Metrics Base Template
## Base template for metrics components.
pattern metrics_base:
    requires element handler

## Secure Zone Template
## Defines connection boundaries that apply to all descendants.
pattern secure_zone:
    forbids connection to external.*
    forbids connection to public_network.*

## Frontend Zone Template
## Frontend components can only connect to API gateway.
pattern frontend_zone:
    allows connection to api_gateway.public_api
    forbids connection to database.*
    forbids connection to internal_services.*

## Backend Zone Template
## Backend components cannot access external systems.
pattern backend_zone:
    forbids connection to external.*

## Service Mesh Zone Template
## Demonstrates requires connection - all services in this zone
## MUST have a dependency on the logging module
pattern service_mesh_zone:
    ## All services in this mesh must import from logging module
    requires connection to logging.*
    
    ## Services may connect to other services in the mesh
    allows connection to mesh_internal.*
    
    ## Services cannot connect directly to external APIs
    forbids connection to external_api.*

## Production Ready Template
## Demonstrates requires descendant implements shorthand
pattern production_ready:
    requires descendant implements dockerized
    requires descendant implements observable

## ============================================================================
## Elements implementing templates
## ============================================================================

## My Application
## A production-ready application that satisfies dockerized requirements.
element my_app implements dockerized, observable:
    scope root = files.folder_selector('.')
    
    ## Frontend service - not dockerized, but that's okay because
    ## the backend satisfies the dockerized requirement
    element frontend:
        scope src = files.folder_selector('frontend/src')
        check files.exists(src, 'index.html')
    
    ## Backend service - this satisfies the dockerized requirement
    element backend:
        scope src = files.folder_selector('backend/src')
        scope dockerfile = docker.file_selector('backend/Dockerfile')
        
        check docker.has_healthcheck(dockerfile)
        check rust.function_exists(src, 'main')
    
    ## Metrics service - this satisfies the observable requirement
    element metrics:
        scope module = rust.module_selector('metrics')
        ref prometheus: MetricsHandler = rust.function_selector(module, 'handler')
        
        check rust.function_exists(module, 'collect_metrics')

## E-Commerce Platform
## Demonstrates connection boundaries through template implementation.
element ecommerce_platform:
    
    ## Public frontend zone - restricted connections via template
    element frontend implements frontend_zone:
        element web_app:
            scope src = files.folder_selector('frontend/web')
            
        element mobile_api:
            scope src = files.folder_selector('frontend/mobile')
    
    ## API Gateway - the single entry point
    element api_gateway:
        scope src = files.folder_selector('gateway/src')
        ref public_api: HttpHandler = rust.function_selector(src, 'routes')
    
    ## Secure backend zone - no external connections allowed via template
    element backend implements backend_zone:
        element order_service:
            scope src = files.folder_selector('services/orders')
            ref orders_api: HttpHandler = rust.function_selector(src, 'orders')
        
        element payment_service implements secure_zone:
            scope src = files.folder_selector('services/payments')
            ref payments_api: HttpHandler = rust.function_selector(src, 'payments')
        
        element database:
            scope config = files.file_selector('db/config.yaml')
            ref db_connection: DbConnection = rust.struct_selector(config, 'Connection')

## Payment Processor
## An example of a deeply secure component with multiple requirements.
element payment_processor implements secure_zone:
    scope root = files.folder_selector('payment')
    
    ## All descendants inherit the forbids connection constraints from secure_zone
    
    element card_validation:
        scope src = files.folder_selector('payment/validation')
        check rust.function_exists(src, 'validate_card')
    
    element tokenization:
        scope src = files.folder_selector('payment/tokenization')
        check rust.function_exists(src, 'tokenize_card')
    
    ## Audit logging - required for compliance
    element audit:
        scope src = files.folder_selector('payment/audit')
        check rust.function_exists(src, 'log_transaction')

## Service Mesh
## Implements service_mesh_zone template for logging requirements.
element service_mesh implements service_mesh_zone:
    element user_service:
        scope src = files.folder_selector('services/user')
        # This service must import from logging.* to satisfy requires connection
    
    element order_service:
        scope src = files.folder_selector('services/order')
        # This service must also import from logging.*
    
    element notification_service:
        scope src = files.folder_selector('services/notification')
        # And this one too
